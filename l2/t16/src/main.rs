// вывод:
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8

// функция, которая запускает трэд отправляющий сообщения из массива в канал
// и возвращает приёмник сообщений канала с i32
fn as_chan(vs: &[i32]) -> std::sync::mpsc::Receiver<i32> {

    // каналы отправки и получения
    let (tx, rx) = std::sync::mpsc::channel();

    // запуск трэда по отправке сообщений
    let handle = std::thread::spawn({

        // конвертация в вектор
        let vs = vs.to_owned();

        // печедача владения в closure
        move || {

            // отправка элементов из массива по очереди в канал получения и ожидание 1 сек
            for v in vs {

                tx.send(v).unwrap();
                std::thread::sleep(std::time::Duration::from_secs(1))

            }

            // сброс канала отправки и остановка трэда
            drop(tx);

        }

    });

    // ожидает оконцание работы канала
    handle.join().unwrap();

    // возвращает содержимое
    rx

}

// функция читает из двух каналов сообщения и записывает полученные данные в новый канал поочерёдно
// возвращает приёмник нового канала
fn merge( a: std::sync::mpsc::Receiver<i32>, b: std::sync::mpsc::Receiver<i32>) -> std::sync::mpsc::Receiver<i32> {
    // новый канал для передачи данных
    let (tx, rx) = std::sync::mpsc::channel();

    // stop-condition для циклов
    let mut a_done = false;

    let mut b_done = false;

    // цикл в котором поочерёдно читаются и записываются в новый канал данные из двух страых каналов;
    // цикл прерывается когда невозможно прочитать новые данные из каналов
    loop {

        match a.try_recv() {

            Ok(i) => {

                tx.send(i).unwrap();

            }

            Err(_) => {

                a_done = true;

            }

        }

        match b.try_recv() {

            Ok(i) => {

                tx.send(i).unwrap();

            }

            Err(_) => {

                b_done = true;

            }

        }

        if a_done && b_done {

            break;

        }

    }

    rx

}

fn main() {
    // запускает и ждет завершения трэда, возвращая приемник канала с полученными данными
    let a = as_chan(&vec![1, 3, 5, 7]);

    // запускает и ждет завершения другого трэда, возвращая приемник канала с полученными данными
    let b = as_chan(&vec![2, 4, 6, 8]);

    // поочередно соединяет два полученных из приемников каналов массива данных и возвращает новый приёмник
    let c = merge(a, b);

    // печатает 1, 2, 3, 4, 5, 6, 7, 8
    for v in c.iter() {
        println!("{v:?}");
    }
}